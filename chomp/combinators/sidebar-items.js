initSidebarItems({"fn":[["choice","Attempts each parser yielded by an iterator in order, returning the result of the first successful parser. This combinator requires boxing of all the parsers returned from the iterator."],["count","Applies the parser `p` exactly `num` times collecting all items into `T: FromIterator`."],["either","Attempts the left parser first and then the right parser if the first parser fails. Result is returned as an `Either<T, U>` depending on which parser succeeded."],["look_ahead","Applies the parser `F` without consuming any input."],["many","Parses many instances of `f` until it does no longer match, collecting all matches into the type `T: FromIterator`."],["many1","Parses at least one instance of `f` and continues until it does no longer match, collecting all matches into the type `T: FromIterator`."],["many_till","Applies the parser `R` multiple times until the parser `F` succeeds and returns a `T: FromIterator` populated by the values yielded by `R`. Consumes the matched part of `F`."],["matched_by","Returns the result of the given parser as well as the slice which matched it."],["option","Tries the parser `f`, on success it yields the parsed value, on failure `default` will be yielded instead."],["or","Tries to match the parser `f`, if `f` fails it tries `g`. Returns the success value of the first match, otherwise the error of the last one if both fail."],["sep_by","Applies the parser `R` zero or more times, separated by the parser `F`. All matches from `R` will be collected into the type `T: FromIterator`."],["sep_by1","Applies the parser `R` one or more times, separated by the parser `F`. All matches from `R` will be collected into the type `T: FromIterator`."],["skip_many","Runs the given parser until it fails, discarding matched input."],["skip_many1","Runs the given parser until it fails, discarding matched input, expects at least one match."]],"mod":[["bounded","Bounded versions of combinators."]]});