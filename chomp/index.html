<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `chomp` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, chomp">

    <title>chomp - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate chomp</p><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'chomp', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>chomp</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/chomp/lib.rs.html#1-327' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Chomp is a fast monadic-style parser combinator library for the Rust programming language. It was
written as the culmination of the experiments detailed in these blog posts:</p>

<ul>
<li><a href="http://m4rw3r.github.io/parser-combinator-experiments-rust">Part 1</a></li>
<li><a href="http://m4rw3r.github.io/parser-combinator-experiments-errors">Part 2</a></li>
<li><a href="http://m4rw3r.github.io/parser-combinator-experiments-part-3">Part 3</a></li>
<li><a href="http://m4rw3r.github.io/parser-combinators-road-chomp-0-1">Chomp 0.1 Announcement</a></li>
</ul>

<p>For its current capabilities, you will find that Chomp performs consistently as well, if not
better, than optimized C parsers, while being vastly more expressive. For an example that
builds a performant HTTP parser out of smaller parsers, see
<a href="examples/http_parser.rs"><code>http_parser.rs</code></a>.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">chomp</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Name</span><span class="op">&lt;</span><span class="ident">B</span>: <span class="ident">Buffer</span><span class="op">&gt;</span> {
    <span class="ident">first</span>: <span class="ident">B</span>,
    <span class="ident">last</span>:  <span class="ident">B</span>,
}

<span class="kw">fn</span> <span class="ident">name</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">U8Input</span><span class="op">&gt;</span>(<span class="ident">i</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">SimpleResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">Name</span><span class="op">&lt;</span><span class="ident">I</span>::<span class="ident">Buffer</span><span class="op">&gt;&gt;</span> {
    <span class="macro">parse</span><span class="macro">!</span>{<span class="ident">i</span>;
        <span class="kw">let</span> <span class="ident">first</span> <span class="op">=</span> <span class="ident">take_while1</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">!=</span> <span class="string">b&#39; &#39;</span>);
                    <span class="ident">token</span>(<span class="string">b&#39; &#39;</span>);  <span class="comment">// skipping this char</span>
        <span class="kw">let</span> <span class="ident">last</span>  <span class="op">=</span> <span class="ident">take_while1</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">!=</span> <span class="string">b&#39;\n&#39;</span>);

        <span class="ident">ret</span> <span class="ident">Name</span>{
            <span class="ident">first</span>: <span class="ident">first</span>,
            <span class="ident">last</span>:  <span class="ident">last</span>,
        }
    }
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">parse_only</span>(<span class="ident">name</span>, <span class="string">&quot;Martin Wernstål\n&quot;</span>.<span class="ident">as_bytes</span>()), <span class="prelude-val">Ok</span>(<span class="ident">Name</span>{
    <span class="ident">first</span>: <span class="kw-2">&amp;</span><span class="string">b&quot;Martin&quot;</span>[..],
    <span class="ident">last</span>: <span class="string">&quot;Wernstål&quot;</span>.<span class="ident">as_bytes</span>()
}));</pre>

<h1 id='usage' class='section-header'><a href='#usage'>Usage</a></h1>
<p>Chomp&#39;s functionality is split between three modules:</p>

<ul>
<li><code>parsers</code> contains the basic parsers used to parse streams of input.</li>
<li><code>combinators</code> contains functions which take parsers and return new ones.</li>
<li><code>primitives</code> contains the building blocks used to make new parsers. This is advanced usage and
is far more involved than using the pre-existing parsers, but is sometimes unavoidable.</li>
</ul>

<p>A parser is, at its simplest, a function that takes a slice of input and returns a
<code>ParserResult&lt;I, T, E&gt;</code>, where <code>I</code>, <code>T</code>, and <code>E</code> are the input, output, and error types,
respectively. Parsers are usually parameterized over values or other parsers as well, so these
appear as extra arguments in the parsing function. As an example, here is the signature of the
<code>token</code> parser, which matches a particular input.</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">token</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Input</span><span class="op">&gt;</span>(<span class="ident">i</span>: <span class="ident">I</span>, <span class="ident">t</span>: <span class="ident">I</span>::<span class="ident">Token</span>) <span class="op">-&gt;</span> <span class="ident">ParseResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">I</span>::<span class="ident">Token</span>, <span class="ident">Error</span><span class="op">&lt;</span><span class="ident">I</span>::<span class="ident">Token</span><span class="op">&gt;&gt;</span> { ... }</pre>

<p>Notice that the first argument is an <code>Input&lt;I&gt;</code>, and the second argument is some <code>I</code>.
<code>Input&lt;I&gt;</code> is just a datatype over the current state of the parser and a slice of input <code>I</code>,
and prevents the parser writer from accidentally mutating the state of the parser. Later, when
we introduce the <code>parse!</code> macro, we will see that using a parser in this macro just means
supplying all of the arguments but the input, as so:</p>

<pre class="rust rust-example-rendered">
<span class="ident">token</span>(<span class="string">b&#39;T&#39;</span>);</pre>

<p>Note that you cannot do this outside of the <code>parse!</code> macro. <code>SimpleResult&lt;I, T&gt;</code> is a
convenience type alias over <code>ParseResult&lt;I, T, Error&lt;u8&gt;&gt;</code>, and <code>Error&lt;I&gt;</code> is just a convenient
&quot;default&quot; error type that will be sufficient for most uses. For more sophisticated usage, one
can always write a custom error type.</p>

<p>A very useful parser is the <code>satisfy</code> parser:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">satisfy</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Input</span>, <span class="ident">F</span><span class="op">&gt;</span>(<span class="kw-2">mut</span> <span class="ident">i</span>: <span class="ident">I</span>, <span class="ident">f</span>: <span class="ident">F</span>) <span class="op">-&gt;</span> <span class="ident">ParseResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">I</span>::<span class="ident">Token</span>, <span class="ident">Error</span><span class="op">&lt;</span><span class="ident">I</span>::<span class="ident">Token</span><span class="op">&gt;&gt;</span>
  <span class="kw">where</span> <span class="ident">F</span>: <span class="ident">FnOnce</span>(<span class="ident">I</span>::<span class="ident">Token</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> { ... }</pre>

<p>Besides the input state, satisfy&#39;s only parameter is a predicate function and will succeed only
if the next piece of input satisfies the supplied predicate. Here&#39;s an example that might be
used in the <code>parse!</code> macro:</p>

<pre class="rust rust-example-rendered">
<span class="ident">satisfy</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> {
    <span class="kw">match</span> <span class="ident">c</span> {
        <span class="string">b&#39;c&#39;</span> <span class="op">|</span> <span class="string">b&#39;h&#39;</span> <span class="op">|</span> <span class="string">b&#39;a&#39;</span> <span class="op">|</span> <span class="string">b&#39;r&#39;</span> <span class="op">=&gt;</span> <span class="bool-val">true</span>,
        _ <span class="op">=&gt;</span> <span class="bool-val">false</span>,
    }
})</pre>

<p>This parser will only succeed if the character is one of the characters in &quot;char&quot;.</p>

<p>Lastly, here is the parser combinator <code>count</code>, which will attempt to run a parser a number of
times on its input.</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">count</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Input</span>, <span class="ident">T</span>, <span class="ident">E</span>, <span class="ident">F</span>, <span class="ident">U</span><span class="op">&gt;</span>(<span class="ident">i</span>: <span class="ident">I</span>, <span class="ident">num</span>: <span class="ident">usize</span>, <span class="ident">p</span>: <span class="ident">F</span>) <span class="op">-&gt;</span> <span class="ident">ParseResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">T</span>, <span class="ident">E</span><span class="op">&gt;</span>
  <span class="kw">where</span> <span class="ident">F</span>: <span class="ident">FnMut</span>(<span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">ParseResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">U</span>, <span class="ident">E</span><span class="op">&gt;</span>,
        <span class="ident">T</span>: <span class="ident">FromIterator</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span> { ... }</pre>

<p>Using parsers is almost entirely done using the <code>parse!</code> macro, which enables us to do three
distinct things:</p>

<ul>
<li>Sequence parsers over the remaining input</li>
<li>Store intermediate results into datatypes</li>
<li>Return a datatype at the end, which may be the result of any arbitrary computation over the
intermediate results.</li>
</ul>

<p>In other words, just as a normal Rust function usually looks something like this:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">f</span>() <span class="op">-&gt;</span> (<span class="ident">u8</span>, <span class="ident">u8</span>, <span class="ident">u8</span>) {
    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">read_number</span>();
    <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">read_number</span>();
    <span class="ident">launch_missiles</span>();
    <span class="kw">return</span> (<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>);
}</pre>

<p>A Chomp parser with a similar structure looks like this:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">f</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">U8Input</span><span class="op">&gt;</span>(<span class="ident">i</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">SimpleResult</span><span class="op">&lt;</span><span class="ident">I</span>, (<span class="ident">u8</span>, <span class="ident">u8</span>, <span class="ident">u8</span>)<span class="op">&gt;</span> {
    <span class="macro">parse</span><span class="macro">!</span>{<span class="ident">i</span>;
        <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">digit</span>();
        <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">digit</span>();
                <span class="ident">string</span>(<span class="string">b&quot;missiles&quot;</span>);
        <span class="ident">ret</span> (<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>)
    }
}

<span class="kw">fn</span> <span class="ident">digit</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">U8Input</span><span class="op">&gt;</span>(<span class="ident">i</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">SimpleResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">u8</span><span class="op">&gt;</span> {
    <span class="ident">satisfy</span>(<span class="ident">i</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="string">b&#39;0&#39;</span> <span class="op">&lt;=</span> <span class="ident">c</span> <span class="op">&amp;&amp;</span> <span class="ident">c</span> <span class="op">&lt;=</span> <span class="string">b&#39;9&#39;</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">-</span> <span class="string">b&#39;0&#39;</span>)
}</pre>

<p>Readers familiar with Haskell or F# will recognize this as a &quot;monadic computation&quot; or
&quot;computation expression&quot;.</p>

<p>You use the <code>parse!</code> macro as follows:</p>

<ul>
<li>Write the input parameter first, with a semicolon.</li>
<li>Write any number of valid parser actions or identifier bindings, where:

<ul>
<li>a parser action takes the form <code>parser(params*)</code>, with the input parameter omitted.</li>
<li>an identifier binding takes the form <code>let identifer = parser(params*);</code>, with the input
parameter omitted.</li>
</ul></li>
<li>Write the final line of the macro, which must always be either a parser action, or a return
statement which takes the form <code>ret expression</code>. The type of <code>expression</code> becomes the return
type of the entire parser, should it succeed.</li>
</ul>

<p>The entire grammar for the macro is listed elsewhere in this documentation.</p>

<h1 id='features' class='section-header'><a href='#features'>Features</a></h1>
<ul>
<li><p><code>backtrace</code>:
disabled (default).</p>

<p>This feature enables backtraces for parse-errors, either by calling <code>Error::trace</code> or by
printing it using <code>fmt::Debug</code>.</p>

<p>This incurs a performance-hit every time a <code>chomp::parsers</code> parser fails since a backtrace
must be collected.</p>

<p>In the <code>dev</code> and <code>test</code> profiles backtraces will always be enabled. This does not incur any
cost when built using the <code>release</code> profile unless the <code>backtrace</code> feature is enabled.</p></li>
<li><p><code>noop_error</code>:
disabled (default).</p>

<p>The built-in <code>chomp::parsers::Error</code> type is zero-sized and carry no error-information. This
increases performance somewhat.</p></li>
<li><p><code>std</code>:
enabled (default).</p>

<p>Chomp includes all features which rely on Rust&#39;s <code>std</code> library. If this is diabled Chomp
will use the <code>no_std</code> feature, only using Rust&#39;s <code>core</code> library.</p>

<p>Items excluded when <code>std</code> is disabled:</p>

<ul>
<li><code>ascii::float</code> support for <code>type::Buffer</code> implementations other than <code>&amp;[u8]</code>.</li>
<li><code>buffer</code> module.</li>
<li><code>combinators::choice</code> combinator.</li>
<li><code>parsers::Error</code> no longer implements the <code>std::error::Error</code> trait.</li>
<li><code>types::Buffer::to_vec</code></li>
<li><code>types::Buffer::into_vec</code></li>
</ul></li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="ascii/index.html"
                                  title='mod chomp::ascii'>ascii</a></td>
                           <td class='docblock-short'>
                                <p>Utilities and parsers for dealing with ASCII data in <code>u8</code> format.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="buffer/index.html"
                                  title='mod chomp::buffer'>buffer</a></td>
                           <td class='docblock-short'>
                                <p>Utilities for parsing streams of data.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="combinators/index.html"
                                  title='mod chomp::combinators'>combinators</a></td>
                           <td class='docblock-short'>
                                <p>Basic combinators.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="parsers/index.html"
                                  title='mod chomp::parsers'>parsers</a></td>
                           <td class='docblock-short'>
                                <p>Basic parsers.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="prelude/index.html"
                                  title='mod chomp::prelude'>prelude</a></td>
                           <td class='docblock-short'>
                                <p>Basic prelude.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="primitives/index.html"
                                  title='mod chomp::primitives'>primitives</a></td>
                           <td class='docblock-short'>
                                <p>Module used to construct fundamental parsers and combinators.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="types/index.html"
                                  title='mod chomp::types'>types</a></td>
                           <td class='docblock-short'>
                                <p>Types which facillitates the chaining of parsers and their results.</p>
                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parse.html"
                                  title='macro chomp::parse'>parse</a></td>
                           <td class='docblock-short'>
                                <p>Macro emulating <code>do</code>-notation for the parser monad, automatically threading the linear type.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parser.html"
                                  title='macro chomp::parser'>parser</a></td>
                           <td class='docblock-short'>
                                <p>Macro wrapping an invocation to <code>parse!</code> in a closure, useful for creating parsers inline.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse_only.html"
                                  title='fn chomp::parse_only'>parse_only</a></td>
                           <td class='docblock-short'>
                                <p>Runs the given parser on the supplied finite input.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.parse_only_str.html"
                                  title='fn chomp::parse_only_str'>parse_only_str</a></td>
                           <td class='docblock-short'>
                                <p>Runs the given parser on the supplied string.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.run_parser.html"
                                  title='fn chomp::run_parser'>run_parser</a></td>
                           <td class='docblock-short'>
                                <p>Runs the supplied parser over the input.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "chomp";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>